적마다 다양한 공격 및 특성
적마다 타입이 다르기에 기본 적 베이스 구조를 만든 후 상속을 사용

EnemyBase c++ 클래스를 만들기
기본적인 데이터 - 생성/동기화/스탯

AIController를 만들어서 이동로직을 제어

OnPossess 메서드 - 부착되었을 때 실행되는 메서드임
AIController는 부착해서 사용하는 메서드임
BeginPlay()도 부착 이후 실행됨

## 가장 가까운 플레이어에게 이동
```c++
// EnemyAIController.cpp  
#include "EnemyAIController.h"  
#include "NavigationSystem.h"  
#include "Engine/PawnIterator.h"  
#include "Kismet/GameplayStatics.h"  
#include "EngineUtils.h"  
  
DEFINE_LOG_CATEGORY(LogEnemyAI);  
  
  
void AEnemyAIController::OnPossess(APawn* InPawn)  
{  
    Super::OnPossess(InPawn);  
  
}  
  
void AEnemyAIController::BeginPlay()  
{  
    Super::BeginPlay();  
    FTimerHandle SearchTimer;  
    GetWorldTimerManager().SetTimer(SearchTimer, this, &AEnemyAIController::UpdateTarget, 0.5f, true);  
}  
  
void AEnemyAIController::UpdateTarget()  
{  
    APawn* Target = FindNearestPlayer();  
    if (Target)  
    {       MoveToActor(Target);  
    }}  
APawn* AEnemyAIController::FindNearestPlayer()  
{  
    float NearestDistance = FLT_MAX;  
    APawn* NearestPawn = nullptr;  
  
    for (TActorIterator<APawn> It(GetWorld()); It; ++It)  
    {       APawn* TestPawn = *It;  
       if (TestPawn && TestPawn->IsPlayerControlled())  
       {          float Distance = FVector::DistSquared(TestPawn->GetActorLocation(), GetPawn()->GetActorLocation());  
          if (Distance < NearestDistance)  
          {             NearestDistance = Distance;             NearestPawn = TestPawn;          }       }    }  
    return NearestPawn;  
}
```
계속해서 가장 가까운 플레이어를 찾으면서 이동
만약 Tick단위로 연산을 할 시 수많은 연산량에 의한 렉 유발
GetWorldTimeManager().SetTimer를 통해서 일정한 시간마다 호출 할 수 있음
특정한 시간마다 UpdateTarget을 호출하면서 가장 가까운 Target으로 MoveToActor
MoveToActor는 호출 될 시 타겟에게 최적의 경로를 찾아서 자동으로 이동시켜주는 함수
NaviMash를 설정해줘야함
### FindNearestPlayer()
가장 가까운 플레이어를 찾는 핵심 로직

## 구현할 적 목록
1. 슈터형 적 (기본 타입의 적으로 플레이어에 접근하여 투사체 발사),
2. 돌진형 적 (조그만하게 무리지어 돌진, 작고 빠름),
3. 슈터형 적+ (연발로 투사체를 날림),
4. 탱커형 적 (몸이 크고 hp가 많음, 느림, 머신건 느낌의 빠른 연발공격),
5. 은신형 적 (플레이어가 가까이 접근해야지 모습이 드러남, 근접),
6. 공중 슈터형 적 (날라다니면서 플레이어를 공격),
7. 스나이퍼형 적 (멀리서 저격),
8. 돌격형 적+ (가까이 와서 폭발),
9. 서포터 적 (주변 적한테 버프를 주는 적),
10. 플레이어 위치에 공격

a. 모델링은 돌려 쓰고 버프만 다르게 해줘도 괜찮을듯 적의 모델링은 어느정도 돌려써도 괜찮을듯 (기본 베이스 슬라임, 하나의 모델링 을 조금씩 변형)

BT와 BTT를 이용해서 만들거임
BT는 적 하나당 하나씩 할당
BTT를 만들어서 재사용성을 늘릴거임
#### BTT 목록
1. FindNearestPlayer
2. MoveTo (언리얼 기본 구현)
3. Shoot(연사하는 적은 Shoot BTT를 여러번 호출하는걸로 사용 가능)
4. Attack(근접)
5. Stealth(은신)
6. Hover(공중 유닛 전용) <- MoveTo 대신 사용
7. Aiming(스나이퍼 유닛이 사용) - Aiming 테스크 이후 Shoot 테스크 호출하는 형식으로
8. Boom(폭발)
9. DropAtk(플레이어 위치에 공격하는 task)
10. Dash(플레이어에게 순간적으로 돌진)
-- 후순위
11. Heal
12. BackStep
13. Split
14. Jump
15. Buff
16. DeBuff
# 어떻게 묶으면 쉬워지나

- **코어 패턴 5개로 템플릿화**
    
    1. **Shooter 템플릿**: 조준/발사(BTT_Fire), 사거리·시야 Decorator, 타겟 갱신 Service(EQS/Perception)  
        → (1 기본 슈터), (3 연발), (6 공중 슈터), (7 스나이퍼), (4 탱커의 머신건) 전부 파라미터로 파생
        
    2. **Charger 템플릿**: 돌진 준비 → 대시 → 후딜(쿨다운)  
        → (2 돌진형), (8 자폭 돌격형) = 끝동작만 폭발로 교체
        
    3. **Melee/근접 템플릿**: 추격 → 근접 범위에서 공격(애님 노티파이)
        
    4. **Stealth 템플릿**: 감지 전엔 은신(메시/머티리얼 토글) → 근접 시 드러남  
        → (5 은신형) = 은신/노출 트리거만 다름
        
    5. **Support 템플릿**: 버프 대상 탐색(EQS: 아군, 체력낮음/특정 태그) → 버프 시전  
        → (9 서포터)
        
- **BT는 ‘언제/무엇’만**, 실제 사격·버프·폭발은 **컴포넌트**에:
    
    - `ShooterCombatComponent`, `ChargeComponent`, `StealthComponent`, `BuffComponent`, `ExplodeComponent` 등
        
    - BT Task는 컴포넌트의 `TryFire() / StartCharge() / ApplyBuff()`만 호출
        

# 파라미터로 갈라치기(데이터 주도)

- **DataTable/DA_EnemyConfig**: HP, 이동속도, 사거리, 발사간격(ROF), 탄속, 탄퍼짐, 탄수(연발/머신건), 장전/쿨다운, 탐지거리, 은신해제거리, 폭발반경/피해량 등
    
- 같은 BT/컴포넌트에 **Config만 바꿔** (1,3,4,6,7)을 커버
    

# 구현 순서 제안(리스크↓)

1. **Shooter 템플릿** 완성 → (1)→(3)→(7) 파생
    
2. **Charger 템플릿** → (2) → 폭발 액션 얹어 (8)
    
3. **Stealth 템플릿** → (5)
    
4. **Support 템플릿** → (9)
    
5. **공중 이동 컴포넌트** 얹어 (6) 마무리
    
6. (10) “플레이어 위치에 공격”은 **Shooter 템플릿의 타겟팅을 위치(Vector)로 스위치**하면 바로 해결 (Blackboard에 `TargetLocation` 추가)
    

# 성능/안정성 체크리스트

- EQS/Service 주기 0.3~~0.6s (틱마다 금지), 인구수 많은 웨이브는 0.6~~1.0s로 늘리기
    
- `BTDecorator_Cooldown`으로 발사/버프 빈도 제한
    
- 네트워크/멀티플레이 시: 발사·폭발은 **서버 권한 체크** 후 리플리케이션
    
- 시야/사거리 Decorator로 불필요한 Move/Fire 차단
    
- 죽은/사라진 타겟 시 `ClearValue` 확실히